# 数据结构篇

## 排序算法

### 插入排序

实现代码如下：

```c++
void insertSort(vector<int> &nums)
{
    if(nums.size()==0) return;
    int tmp;
    for(int i=0;i<nums.size();i++)
    {
        int j=i;
        while(j>0&&nums[j]<nums[j-1])
        {
            tmps=nums[j-1];
            nums[j-1]=nums[j];
            nums[j]=tmp;
            j--;
        }
    }
}
```

 插入排序的最坏时间复杂度是O(n^2),最好是O(n),最好情况是排好序的，这是个稳定的算法。 空间复杂度是O(1)

### 选择排序

实现代码如下：

```c++
void selectSort(vector<int> &nums)
{
    if(nums.size()==0) return;
    int min;
    int tmp;
    for(int i=0;i<nums.size();i++)
    {
        min=i;
        for(int j=i+1;j<nums.size();j++)
        {
            if(nums[j]<nums[min])
                min=j;
        }
        tmp=nums[min];
        nums[min]=nums[i];
        nums[i]=tmp;
    }
}
```

​	最坏最好的时间复杂度都是O(n^2),空间复杂读是O(1)，选择排序算法是不稳定的。

### 冒泡排序

实现代码：

```c++
void dubbleSort(vector<int> &nums)
{
    if(nums.size()==0) return;
    int tmp=0;
    for(int i=0;i<nums.size();i++)
    {
        for(int j=i;j>0;j--)
        {
            if(nums[j]<nums[j-1])
            {
                tmp=nums[j-1];
                nums[j-1]=nums[j];
                nums[j]=tmp;
            }
        }
    }
    
}
```

​	最坏是O(n^2),最好也是O(n^2),这个排序算法是稳定的。

### 快速排序

实现代码：

```java
void quickSort(vector<int> &nums,int start,int end)
{
    if(nums.size()==0) return;
    if(start>=end) return;
    int low=start;
    int high=end;
    int t=nums[low];
    while(low<high)
    {
        while(low<high&&nums[high]>=t)
        {
            high--;
        }
        nums[low]=nums[high];
        while(low<high&&nums[low]<=t)
        {
            low++;
        }
        nums[high]=nums[low];
    }
    nums[low]=t;
    quickSort(nums,start,low-1);
    quickSort(nums,low+1,end);
}
```

 最好时间复杂度是O(NlogN),最坏算法是O(n^2),是一种不稳定的排序算法。

### 归并排序

```c++
void mergeSort(vector<int> &nums,int tmp[],int left,int right)
{
    int mid=(left+right)/2;
    //如果数组只有一个元素，那么就结束分割
    if(left==right) return;
    //一步一步划分数组，直到只有一个元素
    mergeSort(nums,tmp,left,mid);
    mergeSort(nums,tmp,mid+1,right);
    //将子数组拷贝到临时数组
    for(int i=left;i<=right;i++)
    {
        tmp[i]=nums[i];
    }
    int i1=left,i2=mid+1;
    for(int i=left;i<=right;i++)
    {
        //左边的数组耗尽
        if(i1==mid+1)
        {
            nums[i]=tmp[i2++];
        }else if(i2>right) //右边的数组耗尽
        {
            nums[i]=tmp[i1++];
        }
        else if(tmp[i1]>tmp[i2])
        {
            nums[i]=tmp[i2++];
        }
        else
        {
            nums[i]=tmp[i1++];
        }
    }
}
```

​	归并排序的时间复杂度，无论是最好，最差，还是平均都是O(nLogN),空间复杂度是O(n),是一种不稳定的排序算法。	

### 希尔排序

​	基于插入排序，但并不是稳定的

实现代码：

```c++
void shellInsertSort(int a[],int length,int incr)
{
	for(int i=incr;i<length;i+=incr)
	{
		int j=i;
		while(j-incr>=0&&a[j-incr]>a[j])
		{
			int tmp=a[j-1];
			a[j-1]=a[j];
			a[j]=tmp;
			j-=incr;
		}
	}
}
```

### 堆排序

堆，是一颗完全二叉树。

实现代码如下

```c++
void shiftdown(int a[],int pos,length)
{
	//如果是非叶子节点，那就遍历向下
	while(!isLeaf(a[pos]))
	{
		int left=2*pos;
		int right=2*pos+1;
		//右孩子是否在这个树上
		if(right<length)
		{
			left=a[left]>a[right]?left:right;
		}
		//是否需要调整堆
		if(a[pos]>a[left]) return;
		//调整堆
		swap(a,pos,left);
		pos=left;
	}
}
void  buildHeap(int a[],int length)
{
	for(int i=length/2-1;i>=0;i--)
	{
		shiftdown(a,i,length);
	}
}
```

堆排序的最佳、最差、平均的时间复杂度都是 O(NlogN)

堆的删除：过程是将最高的元素和最后的元素交换，然后调整堆。

### 总结

| **排序方法**       | **平均时间** | **最好时间** | **最坏时间** |
| ------------------ | ------------ | ------------ | ------------ |
| 桶排序(不稳定)     | O(n)         | O(n)         | O(n)         |
| 基数排序(稳定)     | O(n)         | O(n)         | O(n)         |
| 归并排序(稳定)     | O(nlogn)     | O(nlogn)     | O(nlogn)     |
| 快速排序(不稳定)   | O(nlogn)     | O(nlogn)     | O(n^2)       |
| 堆排序(不稳定)     | O(nlogn)     | O(nlogn)     | O(nlogn)     |
| 希尔排序(不稳定)   | O(n^1.25)    |              |              |
| 冒泡排序(稳定)     | O(n^2)       | O(n^2)       | O(n^2)       |
| 选择排序(不稳定)   | O(n^2)       | O(n^2)       | O(n^2)       |
| 直接插入排序(稳定) | O(n^2)       | O(n)         | O(n^2)       |

## 树

### 树的周游

#### 前序遍历

```c++
void preOrder(TreeNode* root,vector<int> &order)
{
    if(root==NULL)
    {
        return;
    }
    order.push_back(root->val);
    preOrder(root->left,order);
    preOrder(root->right,order);
}
```

#### 中序遍历

```c++
void inOrder(TreeNOde* root,vector<int> &order)
{
    if(root==NULL) return;
    inOrder(root->left,order);
    order.push_back(root->val);
    inOrder(root->right,order);
}
```

#### 后序遍历

```c++
void afterOrder(TreeNode* root,vector<int> &order)
{
    if(root==NULL) return;
    afterOrder(root->left,order);
    afterOrder(root->right,order);
    order.push_back(root->val);
}
```

#### 层次遍历

```c++
vector<vector<int>> levelOrder(TreeNode * root) {  
        // write your code here  
        vector<vector<int>> result;  
        if(root==NULL) return result;  
        queue<TreeNode*> nodes;  
        nodes.push(root);  
        int i=0;  
        vector<int> tmp;  
        while(nodes.size())  
        {  
            i=nodes.size();  
            int j=0;  
            while(j<i)  
            {  
                TreeNode* t=nodes.front();  
                tmp.push_back(t->val);  
                j++;  
                nodes.pop();  
                if(t->left)  
                    nodes.push(t->left);  
                if(t->right)  
                    nodes.push(t->right);  
            }  
            result.push_back(tmp);  
            tmp.clear();  
        }          
        return result;  
    }  
```



## 高级数据结构

### AVL树

​	AVL树是基于二分法的策略提高数据的查找速度的二叉树的数据结构；

​	平衡二叉树是采用二分法思维把数据按规则组装成一个树形结构的数据，用这个树形结构的数据减少无关数据的检索，大大的提升了数据检索的速度；平衡二叉树的数据结构组装过程有以下规则：

​	非叶子节点只能允许最多两个子节点存在，每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值。

![image-20180530220551083](/Users/youyujie/Documents/Java知识点复习图片/AVL树结构.png)

总结平AVL树特点：

（1）非叶子节点最多拥有两个子节点；

（2）非叶子节值大于左边子节点、小于右边子节点；

（3）树的左右两边的层级数相差不会大于1;

（4）没有值相等重复的节点;

### 红黑树

​	红黑树是一棵二叉查找树，但它在二叉查找树的基础上增加了着色和相关的性质使得红黑树相对平衡，从而保证了红黑树的查找、插入、删除的时间复杂度最坏为O(log n)。

红黑树的五个性质：

1. 每个结点要么是红的要么是黑的。 
2. **根结点是黑的。**
3. 每个叶子结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。 
4. 如果一个结点是红的，那么它的两个儿子都是黑的。 
5. 对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点。

红黑树结构如下：

![image-20180530215640635](/Users/youyujie/Documents/Java知识点复习图片/红黑树.png)

红黑树的左旋：

![image-20180530215757991](/Users/youyujie/Documents/Java知识点复习图片/红黑树左旋.png)

左旋的代码：

```c++
LeftRoate(T, x)  
y ← x.right                    //定义y：y是x的右孩子  
x.right ← y.left                //y的左孩子成为x的右孩子  
if y.left ≠ T.nil  
    y.left.p ← x      
y.p ← x.p                      //x的父结点成为y的父结点  
if x.p = T.nil  
    then T.root ← y  
else if x = x.p.left  
    then x.p.left ← y  
else x.p.right ← y   
y.left ← x                       //x作为y的左孩子  
x.p ← y  
```

红黑树的右旋：

![image-20180530215945905](/Users/youyujie/Documents/Java知识点复习图片/红黑树右旋.png)

​	树在经过左旋右旋之后，树的搜索性质保持不变，但树的红黑性质则被破坏了，所以，红黑树插入和删除数据后，需要利用旋转与颜色重涂来重新恢复树的红黑性质。

### B树

​	B树和平衡二叉树稍有不同的是B树属于多叉树又名平衡多路查找树（查找路径不只两个），数据库索引技术里大量使用者B树和B+树的数据结构。

B树的规则：

（1）树种的每个节点最多拥有m个子节点且m>=2,空树除外（注：m阶代表一个树节点最多有多少个查找路径，m阶=m路,当m=2则是2叉树,m=3则是3叉）；

（2）除根节点外每个节点的关键字数量大于等于ceil(m/2)-1个小于等于m-1个，非根节点关键字数必须>=2;（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2)

（3）所有叶子节点均在同一层、叶子节点除了包含了关键字和关键字记录的指针外也有指向其子节点的指针只不过其指针地址都为null对应下图最后一层节点的空格子

（4）如果一个非叶节点有N个子节点，则该节点的关键字数等于N-1;

（5）所有节点关键字是按递增次序排列，并遵循左小右大原则；

![image-20180530220727843](/Users/youyujie/Documents/Java知识点复习图片/B树结构.png)

**B树的查询流程**： 如上图我要从上图中找到E字母，查找流程如下

（1）获取根节点的关键字进行比较，当前根节点关键字为M，E要小于M（26个字母顺序），所以往找到指向左边的子节点（二分法规则，左小右大，左边放小于当前节点值的子节点、右边放大于当前节点值的子节点）；

（2）拿到关键字D和G，D<E<G 所以直接找到D和G中间的节点；

（3）拿到E和F，因为E=E 所以直接返回关键字和指针信息（如果树结构里面没有包含所要查找的节点则返回null）；

**B树的插入节点流程**

定义一个5阶树（平衡5路查找树;），现在我们要把3、8、31、11、23、29、50、28 这些数字构建出一个5阶树出来;

遵循规则：

（1）当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于cei(5/2)小于等于5-1（关键字数小于cei(5/2) -1就要进行节点合并，大于5-1就要进行节点拆分,非根节点关键字数>=2）；

（2）满足节点本身比左边节点大，比右边节点小的排序规则;

![B树插入节点](/Users/youyujie/Documents/Java知识点复习图片/B树插入节点.jpg)

![B树插入节点2](/Users/youyujie/Documents/Java知识点复习图片/B树插入节点2.jpg)

![B树插入节点3](/Users/youyujie/Documents/Java知识点复习图片/B树插入节点3.jpg)

B树节点的删除

规则：

（1）当前是要组成一个5路查找树，那么此时m=5,关键字数必须大于等于cei(5/2)-1，小于等于5-1，非根节点关键字数大于2；

（2）满足节点本身比左边节点大，比右边节点小的排序规则;

（3）关键字数小于二时先从子节点取，子节点没有符合条件时就向向父节点取，取中间值往父节点放；

![B树的删除](/Users/youyujie/Documents/Java知识点复习图片/B树的删除.jpg)

​	B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度;

### **B+树**

​	B+树是B树的一个升级版，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别

（1）B+跟B树不同B+树的非叶子节点不保存关键字记录的指针，这样使得B+树每个节点所能保存的关键字大大增加；

（2）B+树叶子节点保存了父节点的所有关键字和关键字记录的指针，每个叶子节点的关键字从小到大链接；

（3）B+树的根节点关键字数量和其子节点个数相等;

（4）B+的非叶子节点只进行数据索引，不会存实际的关键字记录的指针，所有数据地址必须要到叶子节点才能获取到，所以每次数据查询的次数都一样；

![B+树结构](/Users/youyujie/Documents/Java知识点复习图片/B+树结构.jpg)

特点：

在B树的基础上每个节点存储的关键字数更多，树的层级更少所以查询数据更快，所有指关键字指针都存在叶子节点，所以每次查找的次数都相同所以查询速度更稳定;







