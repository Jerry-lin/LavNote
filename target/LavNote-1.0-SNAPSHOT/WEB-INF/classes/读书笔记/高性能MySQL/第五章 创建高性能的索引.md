# 第五章 创建高性能的索引

## 5.1索引基础

索引可以包含一个后者多个列的值。MySQL只能高效的使用索引最左边的前缀列。

### 5.1.1索引的类型

**B—Tree索引**

所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。

![image-20180503113032308](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/B-Tree结构.png)

加速数据访问速度，索引对多个值进行排序依据是CREATE TABLE语句中定义索引时序的顺序。

B-Tree索引适合用于全键值、键值范围和键前缀查找。

B-Tree索引的限制

如果不是按照索引最左列开始查找，则无法使用索引。

不能跳过索引的列

如果查询中有某个列的范围查询，则其右边所有列无法使用索引优化查找。

**Hash索引**

基于hash表，只有精确匹配索引所有列的查询才有效。如果多个列hash值相同，那么就按照顺序以链表的形式存储。

![image-20180503114253538](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/Hash数据结构.png)

所有的槽都是有顺序的

哈希索引的限制：

只含有哈希值和指针

哈希索引数据并不是按照索引值顺序存储

哈希索引不支持匹配查找

哈希索引只支持等值比较查询

hash索引非常快，除非有hash冲突

hash冲突过多，那么维护成本较高

InnoDB支持自适应哈希索引，根据使用情况建立哈希索引

**空间数据索引(R-Tree)**

MyISAM支持空间索引，可以用作地理数据存储。

**全文索引**

群文索引是一种特殊的类型索引，它查找的文本中的关键词，而不是直接比较索引中的值。

## 5.2索引的优点

​	除了加快查询之外，B-Tree索引，按照顺序存储数据，所有可以用来做OrderBy和GroupBy操作。

## 5.3高性能索引策略

几种优化方法

###  5.3.1独立的列

指索引列不能是表达式的一部分，也不是函数的参数。我们应该简化where条件的习惯，始终将索引列单独放在比较符的一侧

### 5.3.2前缀索引和索引选择性

有时候需要索引很长的字符列，这时可以索引开始的部分字符，这样可以大大节约索引空间。但是，这样也会降低索引的选择性。

索引的选择性是指，不重复的索引值，也称为基数和数据表记录总数(#T)的比值，范围从1/#T到1之间。

对于BOLB、TEXT或者很长的varchar类型，必须使用前缀索引

前缀索引应该足够长保证较高的选择性，同时也不能太长。

缺点是MySQL无法使用前缀索引在哦ORDER BY和GROUP BY，无法史依弘前缀索引做覆盖扫描。

### 5.3.3多列索引

索引机构合并策略：

将两个单列索引进行扫描后，将结果合并，有三种变种，OR条件的联合，AND条件的相交、组合其两种情况。

优化前

![image-20180503144434193](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/优化前.png)

优化后的SQL

![image-20180503144408342](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/优化后的SQL.png)

索引合并策略有时候是一种优化结果，很湿实际上很多时候很糟糕：

1.服务器对多个索引做相交操作时

2.服务器多多个索引做联合操作时

3.优化器只关心随机页面读取

### 5.3.4选择合适的索引顺序

在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列。

对于如下的查询语句

![image-20180503145226432](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/SQL查询语句1.png)

应该如何的建立索引，选择索引的顺序呢？

我们可以使用where来查看数据基数有多大

![image-20180503145323339](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/SQL1数据基数查询.png)

我们可以看到customer_id基数很小，我们应该将这个索引放在前面建立

我们来看看staff_id列的选择性如何

![image-20180503145524571](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/SQL1的数据基数查询2.png)

这里我们可以看出查询的结果非常依赖于选定的具体值。

### 5.3.5聚簇索引

是一种数据存储方式。

InnoDB的聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。

一个表只能有一个聚簇索引。

![image-20180503150207589](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/聚簇索引的数据分布.png)

InnoDB将通过主键聚集数据，这也就是说途中被索引的列示主键列。如果没有主键，会选择唯一非空索引代替。如果也没有上述规则，会隐式定义一个主键来座位聚簇索引。

**InnoDB和MyISAM的数据分布**

MyISAM可以从表的靠头跳过所需的字节找到需要的行。

![image-20180503151453840](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/MyISAM数据分布.png)

主键分布

![image-20180503151521992](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/MyISAM主键分布.png)

![image-20180503151548971](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/MyISAM非主键分布.png)

InnoDB的数据分布

![image-20180503151633278](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/InnoDB的数据分布.png)

这里看出InnoDB支持聚簇索引，存储的是整张表

与MyISAM不同的是，InnoDB的二级索引和聚簇索引很不相同。InnoDB的二级索引的叶子节点存储的不是行指针，而是主键。

![image-20180503152021069](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/InnoDB的二级索引.png)

![image-20180503152138131](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/聚簇和非聚簇表的对比.png)

**在InnoDB表中按主键顺序插入行**

使用自增序列作为主键。

使用自增序列作为主键和使用UUID作为主键数据对比

![image-20180503152623023](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/InnoDB插入数据测试结果.png)

可以看出UUID作为主键时间更长，索引更大。

在高并发情况希，顺序主键可能导致明显的争用。

### 5.3.6覆盖索引

如果一个索引包含所需要查询的字段值，我们就称为覆盖索引。覆盖索引不需要存储索引列的值，而其然索引不存储索引列的值。MySQL只能使用B-Tree索引作为覆盖索引。

使用如下SQL语句

![image-20180503153719566](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/SQL语句覆盖索引.png)

这里的索引无法覆盖改查询，原因

1，没有任何索引可以覆盖这个查询，但是可以使用where后面的语句

2.MySQL在索引中不能执行Like操作

先将索引扩展至覆盖三个数据列(arist,title,prod_id)

可以使用优化：

![image-20180503153957733](/Users/youyujie/Documents/读书笔记/高性能MySQL/图片/SQL覆盖优化.png)

这种方式叫做延迟关联。

