# 第三章 垃圾回收器与内存分配策略

## 3.1对象存活判断方法

### 3.1.1引用指针算法

思想：又一个地方引用该对象时，那么计数器加1，引用失效时，计数器减1，计数器为0，对象可以被回收

缺点：两个对象内部变量互相引用时，可能永远不被回收

### 3.1.2可达性分析算法

思想：通过一个GC Roots，从上向下搜索，走过的路径称为引用链，不在引用链中的对象可悲回收。

可以作为GC Roots的对象：

虚拟机栈中的引用对象

类静态属性引用的对象

常量引用的对象

本地方法栈中的对象

### 3.1.3引用类型

强引用：随处可见，比如使用new出来的对象

软引用：有用非必需，在发生内存溢出前，进行回收、

弱引用:存活到下一次GC前

虚引用：GC时收到系统通知

### 3.1.4finlize()

对象被回收的时候，调用的方法，可以重写这个方法用于资源回收，

### 3.1.5回收方法区

回收的内容：废弃常量和无用的类

判断一个常量废弃：没有引用指向这个常量

判断一个类无用：

1.实例对象全部回收

2.该类的加载器被回收

3.Class对象没有被任何地方引用

## 3.2垃圾回收算法

### 3.2.1标记-清除算法

标记需要清除的区域，然后回收

优点：高效，实现简单

缺点：产生很多零碎空间

### 3.2.2复制算法

主要用于年轻代回收

Eden和Survivor分为8:1，10%浪费掉

优点：实现简单，高效

缺点:需要移动对象，代价较高

### 3.2.3标记整理

用于老年代

清除需要回收的对象，将存活对象整理在一起

优点:保留较大的空间

缺点：移动对象，代价高

### 3.2.4分代收集

分代收集

新生代：复制算法

老年代：标记整理和标记清除

## 3.3HotSpot的算法实现

### 3.3.1枚举根节点

GC Roots需要上下文或者全局引用

枚举这个Root需要停顿Java执行，使用特定的数据结构，可以快速找到根节点

### 3.3.2安全点

产生安全点的标准是是否具有让程序长时间执行的特征

线程安全停顿的方案：

1.抢占式中断：不现实

2.主动式中断：设置一个标志，线程主动去响应

### 3.3.3安全区域

解决处于组塞或者睡眠的线程无法响应标志的问题

## 3.4垃圾收集器

### 3.4.1Serial收集器

单线程，新生代收集器

### 3.4.2ParNew收集器

多线程版本的Serial收集器

### 3.4.3Parallel Scavenge收集器

多线程收集器，缩短停顿时间

### 3.4.4Serial Old收集器

单线程，老年代收集器

### 3.4.5Parallel Old收集器

老年代多线程收集器，标记整理-算法

### 3.4.6CMS收集器

多线程老年代收集器

使用标记清除算法

### 3.4.7G1收集器

多线程，分代收集器

## 3.5内存分配与回收策略

### 3.5.1对象优先分配在Eden

新生代大多分配在Eden，如果内存不足，将会发生一次Minor GC

Minor GC：新生代垃圾回收，非常频繁，数据较快

Full GC：老年代回收，一般伴有Minor GC，速度较慢

### 3.5.2大对象直接进入老年代

很长的字符串和数组将会在老年代分配

### 3.5.3长期存活的对象进入老年代

使用年龄计数器，Minor GC一次，存活的将会放入Suvivor区，年龄加1，到达15，放入老年区

### 3.5.4动态对象年龄判定

如果在survivor空间相同年龄所有对象大小的综合大于survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

