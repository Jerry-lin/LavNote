



# 第一章 进程管理

## 1.1进程

​	进程是资源调度的基本单位，线程是CPU调度的基本单位。

​	进程提供两种虚拟机制：虚拟处理器和虚拟内存。

​	线程之间可以共享虚拟内存，但是每一个都有各自的虚拟处理器。

​	可以调用fork()来进行线程的复制，从而创建一个新的进程。调用fork()的进程为进程，新产生的进程为子进程。

## 1.2进程描述符以及任务结构

​	Linux内核将进程存放在双向循环链表中。链表中的每一项都是类型为task_struct称为进程描述符。

### 1.2.1分配进程描述符

​	Linux通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色。

### 1.2.2进程描述的存放

​	内核通过一个为一个进程标识值或者PID来标识每一个进程，PID是一个数，实际上是一个int类型。

### 1.2.3进程状态

​	进程有5种状态：

​	1.运行状态：进程是可执行的，它或者正在运行或者在运行队列中等待。

​	2.可中断:进程正在睡眠，或者阻塞，等待条件满足然后开始运行。

​	3.不可中断：除了接受信号也不会被唤醒或者准备投入运行外，这个状态与可中断一样。

​	4.TASK_TRACED 被其他进程跟踪

​	5.停止：进程停止

下面是进程状态转化图：

![image-20180502213935974](/Users/youyujie/Documents/读书笔记/Linux内核/相关图/进程状态转换图.png)

### 1.2.4设置当前进程状态

​	使用set_task_state(task, state);	来设置某个进程的状态

### 1.2.5进程上下文

​	可执行的代码从一个可执行文件载入到进程地址空间执行，一般程序在用户空间执行。当一个程序执行系统调用或者触发了每个异常，它就会陷入内核空间。此时，我们称内核代表进程执行病初愈进程上下文。

### 1.2.6进程家族树

​	进程之间存在一个明显的继承关系。所有的进程都是PID为1的init进程的后代。

​	进程描述符之间有一个指向父进程的指针，和子进程的链表。

## 1.3进程创建

​	linux创建进程的两个函数：fork()和exec()。首先fork函数通过拷贝当前进程创建一个子进程。父进程与子进程的区别仅仅在于PID、PPID和资源、统计量。

​	exec函数负责读取可执行文件将其载入地址空间运行。

### 1.3.1写时拷贝

​	fork函数使用写时拷贝页实现，写时拷贝是一种推迟甚至免拷贝数据的技术。内核并不复制这个那个进程地址空间，而是让父进程和子进程共享同一个拷贝。也就是只读共享，写入拷贝。

​	fork实际开销时复制父进程的页表以及给子进程叉棍见唯一的进程描述符。

### 1.3.2fork()

​	通过clone()系统调用实现fork().然后clone()调用do_fork().

​	do_fork()完成叉棍见中的大部分工作，调用copy_process()函数，然后让进程开始运行。具体实现如下：

​	1.调用dup_task_struct()为新进程叉棍见内核栈、thread_info结构和task_struct,这些值与当前进程的值相同。

​	2.检查用户进程数是否超过所属资源的限制

​	3.子进程着手使自己与父进程区分开来

​	4.子进程状态设置为不可中断状态

​	5.调用copy_flags()更新task_struct的flags成员

​	6.调用alloc_pid()为新进程分配一个有效的PID

​	7.传递给colne函数参数标识，拷贝或者共享资源

​	8.返回一个指向子进程的指针

### 1.3.3vfork()

​	除了不拷贝父进程的页表项外，与fork函数功能相同。子进程作为父进程的单独线程在它的地址空间运行，父进程阻塞，直到子进程退出或者exec()。

## 1.4 线程在LInux中的实现

### 1.4.1创建线程

​	通过clone方法传递参数 来实现线程。

### 1.4.2内核线程

​	内核线程与普通线程之间的区别是内核线程没有独立的地址空间，只在内核运行。

​	内核线程调用do_exit()退出

## 1.5进程终结

### 1.5.1删除进程描述符

### 1.5.2孤儿进程造成的进退维谷

找到他们的父进程，或者init进程，do_exit()退出

​	

​	